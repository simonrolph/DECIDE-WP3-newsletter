---
title: "Send_emails via Rstudio Connect to access SMTP server"
author: "Simon Rolph"
output: html_document
resource_files:
  - "newsletters/2022-08-25/"
  - "data_personal/emails_2022-08-25.rds"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


batch_date <- "2022-08-25"
# ^ this line (14) is updated by code at the end of 1_...Rmd
```


## Introduction

This script sends the MyDECIDE emails from RStudio Connect. The advantage being that it avoids adding the big ugly disclaimer that appears from the bottom of emails sent via the UKCEH normal smtp. This script has some preflight checks to make sure that emails will go out to the right people. Test mode (`test_mode`) if set to true it will send a sample of 50 emails to a gmail address that can then be used to check that they're sending ok.

## Preparatory steps

Generated newsletters (in html format) must be downloaded from JASMIN and placed into a folder with the format `newsletters/{DATE}/`. This file path must then updated in the `resource_files:` part of the YAML header above before deploying. This updating is done automatically by the `1_...` script

## Set up and load data

Load packages

```{r load_packages}
library(blastula)
library(magrittr)

creds <- creds_anonymous(host = "smtp.nerc-lancaster.ac.uk",port=25,use_ssl = T)

test_mode <- TRUE

```

Load the emails data frame

```{r load_emails_dataframe}

emails <- readRDS(paste0("data_personal/emails_",batch_date,".rds"))

#adapt the filepaths to work on rsconnect
for (i in 1:nrow(emails)){
  emails$newsletter_file_location[i] <- gsub("C:/Users/simrol/Documents/R/DECIDE-WP3-newsletter/","", emails$newsletter_file_location[i])
}

nrow(emails)

#in case there are duplicates
emails <- emails[!duplicated(emails$email),]

nrow(emails)



#remove people who requested to unsubscribe but didn't do it through the tool (which I have to add manually to data_personal_unsubbed.txt - each email a new line)
unsubbed <- readLines("data_personal/unsubbed.txt")
emails <- emails[!(emails$email %in% unsubbed),]

nrow(emails)

```

## Preflight checks

Will abort if any identities are incorrect

```{r preflight_checks}
for (i in 1:nrow(emails)){
  #print(i)
  if(file.exists(emails$newsletter_file_location[i])){
    
    #file found, checking identity
    identity_check <- readLines(emails$newsletter_file_location[i],encoding = "UTF-8") %>% 
      paste0(collapse="") %>% 
      gsub("â€™","'",.) %>% #circumvent encoding issue
      grepl(emails$name[i],.)
    
    
    if(!identity_check){
      #if there's an error then abort completely
      print(emails$newsletter_file_location[i]) #what file
      
      print("Expected name:")
      print(emails$name[i]) #what name
      
      print("Opening html for viewing")
      shell.exec(emails$newsletter_file_location[i]) #open file
      
      stop("Identity incorrect for an email. Aborting operation.") #stop
      knitr::knit_exit() #backup stop
    }
    
  } else {
    #indicate if a file is missing but don't abort
    print("File missing:")
    print(emails$newsletter_file_location[i]) #what file
    #missing file
  }
}

if(F){
  #manual visual check
  for (i in 1:nrow(emails)){
    if(file.exists(emails$newsletter_file_location[i])){
      shell.exec(paste0(getwd(),"/",emails$newsletter_file_location[i])) #open file
      Sys.sleep(1)
    }
  }
}

newsletter_file_loc <- paste0("newsletters/",batch_date,"/")

#check are there any duplicates
unique_test <- list.files(newsletter_file_loc) %>%
  paste0(newsletter_file_loc,.) %>%
  sapply(readLines,encoding = "UTF-8") %>%
  sapply(paste0,collapse="")

if(length(unique_test) != length(unique(unique_test))){
  stop("Duplicate emails detected! Aborting operation.")
}



# file size the same?
file_size_test <- list.files(newsletter_file_loc) %>%
  paste0(newsletter_file_loc,.) %>%
  sapply(function(x){file.info(x)$size})

length(file_size_test)
length(unique(file_size_test))

file_size_test[duplicated(file_size_test) | duplicated(file_size_test, fromLast=TRUE)]
```


## Sending emails

Loop through and send the emails

```{r send_emails}

if(test_mode){
  i_emails <- round(runif(50,0,nrow(emails)))
} else {
  i_emails <- 1:nrow(emails)
}


#loop through each email and send it
for (i in i_emails){
  print(i)

  #define sender and recipient (could change this for testing, eg. set the recipient to your email to generate a batch of emails for different users but then see what they look like in your own inbox without spamming real users.)
  sender <- "DECIDE@ceh.ac.uk"

  if(file.exists(emails$newsletter_file_location[i])){

    #final identity check (does the name of the person appear in the email content)
    identity_check <- readLines(emails$newsletter_file_location[i]) %>% paste0(collapse="") %>% grepl(emails$name[i],.)

    if(identity_check){
      # turn the rendered markdown into a blastula ready email object
      email_obj <- blastula:::cid_images(emails$newsletter_file_location[i])

      print("sending to: ")
      print(c(emails$email[i]))
      
      if(test_mode){
        send_to_email <- "decidenewsletter@gmail.com"
        subject <- paste0("MyDECIDE to ",c(emails$email[i]))
      } else{
        send_to_email <- c(emails$email[i])
        subject <- "MyDECIDE"
      }

      #send email
      smtp_send(email_obj,
                from = sender,
                to = send_to_email,
                subject = subject,
                credentials = creds,
                verbose = F
      )

    } else {
      print(i)
      print("Identity not match, not sending email")
    }

    Sys.sleep(1)
  } else {
    print("file not found. Email not sent.")
  }

}

#delete all the files
#sapply(emails$newsletter_file_location, unlink)

```
